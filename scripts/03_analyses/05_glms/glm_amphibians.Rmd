---
title: "glm_amphibians"
output: html_document
date: "2024-05-15"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(ncf)
library(DHARMa)
source("./../../00_functions/00_functions.R")

options(na.action = "na.omit")

```

# SES verticality

VIF variable selection

```{r}
env = read.csv("./../../../data/derivative_data/env_data.csv")

# variable selection 
env_vars = vif_func(in_frame = env[c(4, 7:12,17:18,22)], thresh = 5, trace = T)

```


```{r}
amph = read.csv("data/derivative_data/gridcell_data/amphibians_comdat/amph_comdat_parallel_forestsOnly.csv")

sesvert = amph[,c("x", "y", "vert.mean.ses", "biome", "realm", env_vars)] %>% 
  drop_na()

hist(sesvert$vert.mean.ses)

```

Look at the correlation between variables
The strongest correlation coefficient is between tmax_warm and tmin_cold at 0.62
```{r}
pairs(sesvert[,6:13])
cor(sesvert[,6:13], method = "pearson")

```


Check linear association between predictor and response
```{r}
as.data.frame(sesvert) %>% 
  pivot_longer(cols = 6:ncol(sesvert), names_to = "vars", values_to = "val") %>% 
  ggplot(aes(x = val, y = vert.mean.ses)) +
  geom_point(col = "grey", alpha = 0.2, size = 1) +
  geom_smooth(col = "blue", method = "lm") +
  facet_wrap(facets = vars(vars), scales = "free_x") +
  theme_classic()

```

There is not apparent nonlinearity between response and predictors for any variables except for tmin_cold. However, there are non-homogeneous variances.

Next, we need to examine spatial autocorrelation in the response variable
```{r}
correlog = ncf::correlog(x = sesvert$x, y = sesvert$y, z = sesvert$vert.mean.ses, increment = 111000, resamp = 100, latlon = F)
plot(correlog)
save(correlog, file = "glm_amphibian_objects.RData")
correlog.df = data.frame(distclass = correlog$mean.of.class, moranI = correlog$correlation, p = correlog$p)

# this takes a long time to run
# do we get the same result if we subsample the points

sesvert.sub = sesvert %>% 
  slice_sample(n=1000)

correlog.sub = ncf::correlog(x = sesvert.sub$x, y = sesvert.sub$y, z = sesvert.sub$vert.mean.ses, increment = 111000, resamp = 100, latlon = F)
plot(correlog.sub)
save.image(file = "glm_amphibian_objects.RData")

# zoom in on plot
plot(correlog.sub, xlim = c(0,5e6))
correlog.sub$x.intercept
correlog.sub.df = data.frame(dist = correlog.sub$mean.of.class, moranI = correlog.sub$correlation, p = correlog.sub$p)
```


We know that there is spatial autocorrelation in the response variable and that there are nonhomogeneous variances and potential non-linearities with response variables. But before we start adjusting anything, we will run a simple linear regression to start.

```{r}
# first set the formula

f = formula(vert.mean.ses ~ tmax_warm + tmin_cold + precip_wet + precip_dry + precip_sea + clim_velocity + elev + veg_complexity)

# before running the model, we will scale the predictor variables so that coefficients are comparable
sesvert.scale = sesvert %>% 
  mutate_at(.vars = 6:ncol(sesvert), .funs = function(x){scale(x)})
colnames(sesvert.scale) = colnames(sesvert)

mod.lm1 = lm(f, data = sesvert.scale)

# look at validation plots
plot(mod.lm1)
hist(mod.lm1$residuals)

# not bad residual plots - some slightly high residuals, which I suspect are caused by clim_velocity

# check spatial autocorrelation
# subset residuals to look at spatial autocorrelation
resid.sub = data.frame(x = sesvert$x, y = sesvert$y, resid = mod.lm1$residuals) %>% slice_sample(n = 1000)
correlog.m1.resid = ncf::correlog(x = resid.sub$x, y = resid.sub$y, z = resid.sub$resid, increment = 111000, resamp = 100, latlon = F)

plot(correlog.m1.resid)

# there is clear spatial autocorrelation in the residuals until 1294 km

correlog.m1.resid$x.intercept

# save model coefficients
mod.lm1.summ = summary(mod.lm1)
#coefs.df = data.frame(estimate = mod.lm1.summ$coefficients[,1], se = mod.lm1.summ$coefficients[,2], p = mod.lm1.summ$coefficients[,4]) %>% 
#  mutate(mod = "mod.lm1")

# run the same model using glm instead of lm
mod.glm1 = glm(f, data = sesvert.scale)
plot(mod.glm1)

# get quantile residuals with DHARMA package
mod.glm1.resid = simulateResiduals(mod.glm1)

# look at spatial autocorrelation in resids
resid.sub = data.frame(x = sesvert.scale$x, y = sesvert.scale$y, resid = residuals(mod.glm1.resid)) %>% slice_sample(n = 1000)
correlog.glm1.resid = ncf::correlog(x = resid.sub$x, y = resid.sub$y, z = resid.sub$resid, increment = 111000, resamp = 100, latlon = F)
plot(correlog.glm1.resid) # clear spatial autocorrelation

# also test overall autocorrelation using Dharma
testSpatialAutocorrelation(mod.glm1.resid, x = sesvert.scale$x, y = sesvert.scale$y, plot = F)

# add coefficients to comparison dataframe
glm1.summ = summary(mod.glm1)
glm1.summ = data.frame(estimate = glm1.summ$coefficients[,1], se = glm1.summ$coefficients[,2], p = glm1.summ$coefficients[,4])
glm1.summ$mod = "mod.glm1"
glm1.summ$var = rownames(glm1.summ)

#coefs.df = bind_rows(coefs.df, glm1.summ)
```



We know that there is spatial autocorrelation in the residuals and that the residuals are not quite normally distributed.
First we address the issue of spatial autocorrelation by subsetting the data to the point x-intercept of the correlogram
```{r}
library(enmSdmX)

sesvert.scale.sf = st_as_sf(sesvert.scale, coords = c("x", "y"), remove = F)
st_crs(sesvert.scale.sf) = "+proj=cea +datum=WGS84"

# thin points by x-intercept of correlogram from glm residuals
sesvert.scale.thin = geoThin(sesvert.scale.sf, minDist = correlog.glm1.resid$x.intercept, method = "complete")
sesvert.scale.thin = as.data.frame(sesvert.scale.thin)

# run glm on thinned points (only 122 points left after thinning)
mod.glm.thin = glm(f, data = sesvert.scale.thin)
plot(mod.glm.thin) # some patterning in residuals

# get quantile residuals with DHARMA package
mod.glmthin.resid = simulateResiduals(mod.glm.thin)

# look at spatial autocorrelation in resids
correlog.glmthin.resid = ncf::correlog(x = sesvert.scale.thin$x, y = sesvert.scale.thin$y, z = residuals(mod.glmthin.resid), increment = correlog.glm1.resid$x.intercept, resamp = 100, latlon = F)
plot(correlog.glmthin.resid) # clear spatial autocorrelation

# also test overall autocorrelation using Dharma
testSpatialAutocorrelation(mod.glmthin.resid, x = sesvert.scale.thin$x, y = sesvert.scale.thin$y, plot = F)

# add coefficients to comparison dataframe
glmthin.summ = summary(mod.glm.thin)
glmthin.summ = data.frame(estimate = glmthin.summ$coefficients[,1], se = glmthin.summ$coefficients[,2], p = glmthin.summ$coefficients[,4])
glmthin.summ$mod = "mod.glm.thin"
glmthin.summ$var = rownames(glmthin.summ)

coefs.df = bind_rows(glm1.summ, glmthin.summ)

```


How do the coefficients compare between glm and thinned glm
```{r}
ggplot(coefs.df) +
  geom_pointrange(aes(x = estimate, xmin = estimate-se, xmax = estimate+se, y = var, color = mod))
save.image(file = "glm_amphibian_objects.RData")
```


Load the SAR models for amphibians
```{r}
load("./../../../results/sar_mods_forestOnly_forestSES/amphibians/amphibians_sar_sesvert.RData")
sar.summ = summary(sesvert.avg)$coefmat.full
sar.summ = data.frame(estimate = sar.summ[,1], se = sar.summ[,2], p = sar.summ[,4], mod = "sar")
sar.summ$var = rownames(sar.summ)
coefs.df = bind_rows(coefs.df, sar.summ)

ggplot(coefs.df) +
  geom_pointrange(aes(y = estimate, ymin = estimate-se, ymax = estimate+se, x = var, color = mod),
                  position = position_dodge()) +
  coord_flip()

```

There are some clear differences, but we have not transformed the predictor variables for the glm.
Try transforming the same as for sar models and then compare.

```{r}
as.data.frame(sesvert) %>% 
  pivot_longer(cols = 6:ncol(sesvert), names_to = "vars", values_to = "val") %>% 
  ggplot(aes(x = val, y = vert.mean.ses)) +
  geom_point(col = "grey", alpha = 0.2, size = 1) +
  geom_smooth(col = "blue", method = "lm") +
  facet_wrap(facets = vars(vars), scales = "free_x") +
  theme_classic()

sesvert.t = as.data.frame(sesvert) %>% 
  mutate(log_clim_velocity = log10(clim_velocity),
         log_elev = log10(elev),
         log_precip_sea = log10(precip_sea),
         log_precip_dry = log10(precip_dry+1))

sesvert.t %>% 
  pivot_longer(cols = 6:ncol(sesvert.t), names_to = "vars", values_to = "val") %>% 
  ggplot(aes(x = val, y = vert.mean.ses)) +
  geom_point(col = "grey", alpha = 0.2, size = 1) +
  geom_smooth(col = "blue", method = "lm") +
  facet_wrap(facets = vars(vars), scales = "free_x") +
  theme_classic()

# keep log transformation for climate velocity and elevation
sesvert.t = sesvert.t %>% 
  dplyr::select(!c(clim_velocity, elev, log_precip_sea, precip_dry))
# add quadratic term to model for tmin_cold


# scale predictor variables
sesvert.scale = sesvert.t %>% 
  mutate_at(.vars = 6:ncol(sesvert.t), .funs = function(x){scale(x)})
colnames(sesvert.scale) = colnames(sesvert.t)

f = formula(vert.mean.ses ~ log_elev + log_clim_velocity + tmax_warm + tmin_cold + log_precip_dry + precip_sea + precip_wet + veg_complexity)

```


Run the glm with and withoug thinning the points
```{r}
# run the same model using glm instead of lm
mod.glm1 = glm(f, data = sesvert.scale)
plot(mod.glm1)

# get quantile residuals with DHARMA package
mod.glm1.resid = simulateResiduals(mod.glm1)

# look at spatial autocorrelation in resids
resid.sub = data.frame(x = sesvert.scale$x, y = sesvert.scale$y, resid = residuals(mod.glm1.resid)) %>% slice_sample(n = 1000)
correlog.glm1.resid = ncf::correlog(x = resid.sub$x, y = resid.sub$y, z = resid.sub$resid, increment = 111000, resamp = 100, latlon = F)
plot(correlog.glm1.resid, xlim = c(0,5e6), ylim = c(-1,1)) # clear spatial autocorrelation

# also test overall autocorrelation using Dharma
testSpatialAutocorrelation(mod.glm1.resid, x = sesvert.scale$x, y = sesvert.scale$y, plot = F)

# add coefficients to comparison dataframe
glm1.summ = summary(mod.glm1)
glm1.summ = data.frame(estimate = glm1.summ$coefficients[,1], se = glm1.summ$coefficients[,2], p = glm1.summ$coefficients[,4])
glm1.summ$mod = "mod.glm1"
glm1.summ$var = rownames(glm1.summ)


```

Now for the thinned points
```{r}
sesvert.scale.sf = st_as_sf(sesvert.scale, coords = c("x", "y"), remove = F)
st_crs(sesvert.scale.sf) = "+proj=cea +datum=WGS84"

# thin points by x-intercept of correlogram from glm residuals
sesvert.scale.thin = geoThin(sesvert.scale.sf, minDist = correlog.glm1.resid$x.intercept, method = "complete")
sesvert.scale.thin = as.data.frame(sesvert.scale.thin)

# run glm on thinned points (only 122 points left after thinning)
mod.glm.thin = glm(f, data = sesvert.scale.thin)
plot(mod.glm.thin) # some patterning in residuals

# get quantile residuals with DHARMA package
mod.glmthin.resid = simulateResiduals(mod.glm.thin)

# look at spatial autocorrelation in resids
correlog.glmthin.resid = ncf::correlog(x = sesvert.scale.thin$x, y = sesvert.scale.thin$y, z = residuals(mod.glmthin.resid), increment = correlog.glm1.resid$x.intercept, resamp = 100, latlon = F)
plot(correlog.glmthin.resid) # clear spatial autocorrelation

# also test overall autocorrelation using Dharma
testSpatialAutocorrelation(mod.glmthin.resid, x = sesvert.scale.thin$x, y = sesvert.scale.thin$y, plot = F)

# add coefficients to comparison dataframe
glmthin.summ = summary(mod.glm.thin)
glmthin.summ = data.frame(estimate = glmthin.summ$coefficients[,1], se = glmthin.summ$coefficients[,2], p = glmthin.summ$coefficients[,4])
glmthin.summ$mod = "mod.glm.thin"
glmthin.summ$var = rownames(glmthin.summ)

coefs.df = bind_rows(glm1.summ, glmthin.summ)
```


Compare coefs to SAR model
```{r}
coefs.df = bind_rows(coefs.df, sar.summ)

ggplot(coefs.df) +
  geom_pointrange(aes(y = estimate, ymin = estimate-se, ymax = estimate+se, x = var, color = mod),
                  position = position_dodge()) +
  coord_flip()
```

What do predictions from the different models look like?
```{r}
predict.glm1 = predict(mod.glm1, newdata = sesvert.scale, type = "response")
hist(predict.glm1)
hist(sesvert.scale$vert.mean.ses)

glm1.df = data.frame(x = sesvert.scale$x, y = sesvert.scale$y, resid = mod.glm1$residuals, pred = predict.glm1)
plot(glm1.df$pred, glm1.df$resid)
abline(a = 0, b = 0, col = "red3")

plot(sesvert.scale$vert.mean.ses, glm1.df$pred, ylim = c(-4,6))
abline(a = 0, b = 1, col = "red3")

ggplot(glm1.df) +
  geom_tile(aes(x=x, y=y, fill = resid)) +
  scale_fill_continuous_divergingx("spectral") +
  coord_sf(crs = "+proj=cea +datum=WGS84") +
  theme_classic()

predict.glmthin = predict(mod.glm.thin, newdata = sesvert.scale.thin, type = "response")
hist(predict.glmthin)

glmthin.df = data.frame(x = sesvert.scale.thin$x, y = sesvert.scale.thin$y, pred = predict.glmthin, resid = mod.glm.thin$residuals)
plot(glmthin.df$pred, glmthin.df$resid)
abline(a = 0, b = 0, col = "red3")

plot(sesvert.scale.thin$vert.mean.ses, glmthin.df$pred, ylim = c(-4,3))
abline(a = 0, b = 1, col = "red3")

ggplot(glmthin.df) +
  geom_point(aes(x=x, y=y, color = resid), size = 2) +
  scale_color_continuous_divergingx("spectral") +
  coord_sf(crs = "+proj=cea +datum=WGS84") +
  theme_classic()
```


Looks like high values are still compressed as in SAR model
```{r}
plot(predict.glm1, mod.glm1$residuals)
plot(sesvert.scale$tmax_warm, mod.glm1$residuals)
plot(sesvert.scale$tmin_cold, mod.glm1$residuals)
plot(sesvert.scale$precip_wet, mod.glm1$residuals)
plot(sesvert.scale$precip_sea, mod.glm1$residuals)
plot(sesvert.scale$veg_complexity, mod.glm1$residuals)
plot(sesvert.scale$log_clim_velocity, mod.glm1$residuals)
plot(sesvert.scale$log_elev, mod.glm1$residuals)
plot(sesvert.scale$log_precip_dry, mod.glm1$residuals)

glm1.resids = data.frame(x = sesvert.scale$x, y = sesvert.scale$y, resid = mod.glm1$residuals, 
                         vert.mean.ses = sesvert.scale$vert.mean.ses, 
                         vert.mean.ses.pred = predict.glm1)

ggplot(glm1.resids) +
  geom_tile(aes(x = x, y = y, fill = resid)) +
  coord_sf(crs = "+proj=cea +datum=WGS84")

ggplot(glm1.resids) +
  geom_tile(aes(x = x, y = y, fill = vert.mean.ses - vert.mean.ses.pred)) +
  coord_sf(crs = "+proj=cea +datum=WGS84") +
  scale_fill_continuous_divergingx("spectral")


glmthin.resids = data.frame(x = sesvert.scale.thin$x, y = sesvert.scale.thin$y, resid = mod.glm.thin$residuals, 
                         vert.mean.ses = sesvert.scale.thin$vert.mean.ses, 
                         vert.mean.ses.pred = predict.glmthin)

ggplot(glmthin.resids) +
  geom_point(aes(x = x, y = y, color = vert.mean.ses - vert.mean.ses.pred)) +
  coord_sf(crs = "+proj=cea +datum=WGS84") +
  scale_color_continuous_divergingx("spectral")


# now plot from SAR models
ggplot(pred.df) +
  geom_tile(aes(x = x, y = y, fill = vert.mean.ses - pred.pres.trend)) +
  coord_sf(crs = "+proj=cea +datum=WGS84") +
  scale_fill_continuous_divergingx("spectral") +
  theme_classic()

ggplot(pred.df) +
  geom_tile(aes(x = x, y = y, fill = vert.mean.ses - pred.signal)) +
  coord_sf(crs = "+proj=cea +datum=WGS84") +
  scale_fill_continuous_divergingx("spectral") +
  theme_classic()

pred.signal = predict(sesvert.avg)
pred.df$pred.signal = pred.signal

# plot predictions with signal
ggplot(pred.df) +
  geom_tile(aes(x = x, y = y, fill = pred.signal)) +
  coord_sf(crs = "+proj=cea +datum=WGS84") +
  scale_fill_continuous_divergingx("spectral", rev = T, limits = c(-5,6.8)) +
  theme_classic()

ggplot(pred.df) +
  geom_tile(aes(x = x, y = y, fill = vert.mean.ses)) +
  coord_sf(crs = "+proj=cea +datum=WGS84") +
  scale_fill_continuous_divergingx("spectral", rev = T, limits = c(-5,6.8)) +
  theme_classic()

ggplot(pred.df) +
  geom_tile(aes(x = x, y = y, fill = pred.pres.trend)) +
  coord_sf(crs = "+proj=cea +datum=WGS84") +
  scale_fill_continuous_divergingx("spectral", rev = T, limits = c(-5,6.8)) +
  theme_classic()

ggplot(pred.df) +
  geom_tile(aes(x = x, y = y, fill = pred.future)) +
  coord_sf(crs = "+proj=cea +datum=WGS84") +
  scale_fill_continuous_divergingx("spectral", rev = T, limits = c(-5,6.8)) +
  theme_classic()

plot(pred.df$vert.mean.ses, pred.df$pred.signal)
abline(a = 0, b = 1, col = "red3")

plot(pred.df$vert.mean.ses, pred.df$pred.pres.trend, ylim = c(-4,6))
abline(a = 0, b = 1, col = "red3")

plot(pred.df$vert.mean.ses, pred.df$vert.mean.ses - pred.df$pred.pres.trend, ylim = c(-4,6))
abline(a = 0, b = 0, col = "red3")

plot(pred.df$vert.mean.ses, pred.df$vert.mean.ses - pred.df$pred.signal, ylim = c(-4,6))
abline(a = 0, b = 0, col = "red3")
```


I suspect the model is misspecified, but I don't know what else to include in the model.
Something other than environmental variables is causing high verticality in the tropics


Try with phylogenetic distance in the models
```{r}
amph = read.csv("./../../../data/derivative_data/gridcell_data/amphibians_comdat/amph_comdat_parallel_forestsOnly.csv")

sesvert = amph[,c("x", "y", "vert.mean.ses", "biome", "realm", "mpd.obs.z", env_vars)] %>% 
  drop_na()

as.data.frame(sesvert) %>% 
  pivot_longer(cols = 6:ncol(sesvert), names_to = "vars", values_to = "val") %>% 
  ggplot(aes(x = val, y = vert.mean.ses)) +
  geom_point(col = "grey", alpha = 0.2, size = 1) +
  geom_smooth(col = "blue", method = "lm") +
  facet_wrap(facets = vars(vars), scales = "free_x") +
  theme_classic()

sesvert.t = as.data.frame(sesvert) %>% 
  mutate(log_clim_velocity = log10(clim_velocity),
         log_elev = log10(elev),
         log_precip_sea = log10(precip_sea),
         log_precip_dry = log10(precip_dry+1))

sesvert.t %>% 
  pivot_longer(cols = 6:ncol(sesvert.t), names_to = "vars", values_to = "val") %>% 
  ggplot(aes(x = val, y = vert.mean.ses)) +
  geom_point(col = "grey", alpha = 0.2, size = 1) +
  geom_smooth(col = "blue", method = "lm") +
  facet_wrap(facets = vars(vars), scales = "free_x") +
  theme_classic()

# keep log transformation for climate velocity and elevation
sesvert.t = sesvert.t %>% 
  dplyr::select(!c(clim_velocity, elev, log_precip_sea, precip_dry))
# add quadratic term to model for tmin_cold


# scale predictor variables
sesvert.scale = sesvert.t %>% 
  mutate_at(.vars = 6:ncol(sesvert.t), .funs = function(x){scale(x)})
colnames(sesvert.scale) = colnames(sesvert.t)

f = formula(vert.mean.ses ~ log_elev + log_clim_velocity + tmax_warm + tmin_cold + log_precip_dry + precip_sea + precip_wet + veg_complexity + mpd.obs.z)

```

Run a linear model including phylodistance
```{r}
mod.glm2 = glm(f, data = sesvert.scale)
plot(mod.glm2)

plot(sesvert.scale$vert.mean.ses, mod.glm2$fitted.values, ylim = c(-4,6))
abline(a = 0, b = 1, col = "red3")

glm2.summ = summary(mod.glm2)
glm2.summ = glm2.summ$coefficients
colnames(glm2.summ)[2] = "se"
colnames(glm2.summ)[4] = "p"
glm2.summ = as.data.frame(glm2.summ)
glm2.summ$var = rownames(glm2.summ)


ggplot(glm2.summ) +
  geom_pointrange(aes(x = Estimate, y = var, xmin = Estimate-se, xmax = Estimate+se, color = p<0.05)) +
  geom_vline(xintercept = 0)

```

```{r}
ggplot(glm1.df)
```





